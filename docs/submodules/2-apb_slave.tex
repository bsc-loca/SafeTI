\subsubsection{APB Slave Interface}\label{section:apb}

\paragraph{Register specifications}
The traffic injector is controlled and monitored through registers mapped into a defined APB address space using the VHDL generics \code{paddr} and \code{pmask} as described in Table \ref{table:generics}.\\
The current injector version implements the shown registers in Table \ref{table:apb_registers}. Note how descriptors ranging from \code{0x10} up to \code{0x24} are used for debug capabilities and could be disabled to reduce the module footprint without losing any feature.

\begin{table}[ht]
	\scriptsize
	\centering
	\begin{tabular}{ll}
		\hline
		APB Address Offset & Register
		\\
		\hline
		0x00 & Control Register
		\\
		0x04 & Status Register
		\\
		0x08 & First descriptor pointer
		\\
		0x0C & Future capabilities register
		\\
		0x10 & \textbf{Debug} Descriptor control word
		\\
		0x14 & \textbf{Debug} Next descriptor pointer
		\\
		0x18 & \textbf{Debug} Destination address
		\\
		0x1C & \textbf{Debug} Source address
		\\
		0x20 & \textbf{Debug} Descriptor status
		\\
		0x24 & \textbf{Debug} Current descriptor pointer
		\\
		\hline
	\end{tabular}
	\caption{APB register map}
	\label{table:apb_registers}
\end{table}

% CONTROL REGISTER
\newpage
\paragraph{Control} %need subparagraph
The Control register allows the configuration of interrupt generation on error and descriptor completion. There are designated bits which allows different functionalities like kicking, enabling, resetting and enabling the QMode.\\
\begin{register}{H}{Control register}{CTRL~-~0x00}
    \label{reg_control}%
    \regfield{Reserved}{26}{6}{0}%
    \regfield{QM}{1}{5}{0}%
    \regfield{IER}{1}{4}{0}%
    \regfield{IE}{1}{3}{0}%
    \regfield{KCK}{1}{2}{0}%
    \regfield{RST}{1}{1}{0}%
    \regfield{EN}{1}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[Request~Depth]
        \item [QM]Queue mode:
		\begin{itemize}
  		\item 0: Sequential queue
  		\item 1: Circular queue
		\end{itemize}
        \item [IER]Enable interrupt on error events.
        \item [IE]\begin{itemize}
  		\item 0: Disable interrupt
  		\item 1: Enable interrupt
		\end{itemize}
        \item [KCK]Kick Injector. Reads the current descriptor next address again 
	(if an error occurs or new descriptor is added to the completed queue).
        \item [RST]Reset injector. Setting this bit to one resets the core completely.
        \item [EN]Enable Injector controller
		\begin{itemize}
  		\item 0: Disabled
  		\item 1: Enabled
		\end{itemize}
\end{reglist}\end{regdesc}\end{register}


% STATUS REGISTER
\newpage
\paragraph{Status}
Display of any error specified in \ref{section:descriptors}, current injector status from its internal FSM, and completion monitoring.\\
\vspace{0.3cm}

\begin{register}{H}{Status register}{STS~-~0x04}
    \label{reg_sts}
    \regfield{Reserved}{11}{21}{0}%
    \regfield{CNT}{6}{15}{0}%
    \regfield{ST}{5}{10}{0}%
    \regfield{NPE}{1}{9}{0}%
    \regfield{WDE}{1}{8}{0}%
    \regfield{RDE}{1}{7}{0}%
    \regfield{RE}{1}{6}{0}%
    \regfield{DE}{1}{5}{0}%
    \regfield{IF}{1}{4}{0}%
    \regfield{KCK}{1}{3}{0}%
    \regfield{ONG}{1}{2}{0}%
    \regfield{ERR}{1}{1}{0}%
    \regfield{CMP}{1}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[Request~Depth]
        \item [CNT]Current transaction repetition count value.
        \item [ST]Current Injector operation state.
        \item [NPE]Error while reading next descriptor pointer register.
        \item [WDE]Error while witing data during Control to Master transaction. Write Interface error.
        \item [RDE]Error while reading data during Master to Control transaction. Read Interface error.
        \item [RE]Read descriptor error.
        \item [DE]Decode descriptor error.
        \item [IF]Interrupt flag.
        \item [KCK]Kick flag pending to be executed.
        \item [ONG]Ongoing descriptor queue execution.
        \item [ERR]Error flag during descriptor queue execution.
        \item [CMP]Completed execution of the descriptor queue.
\end{reglist}\end{regdesc}\end{register}


%FIRST DESCRIPTOR POINTER
\paragraph{First descriptor pointer} Defines the first address where the first descriptor is allocated.\\

\begin{register}{H}{First descriptor pointer}{FPTR~-~0x08}
    \label{reg_fptr}%
    \regfield{addr}{32}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[Request~Depth]
        \item [addr]First descriptor pointer register. Points to the first descriptor of the queue.
\end{reglist}\end{regdesc}\end{register}


% FUTURE CAPABILITIES REGISTER
\newpage
\paragraph{Future capabilities} It is a reserved register that has already been specified for future module releases. Just like the \textbf{Debug APB Registers}, this register can be disabled.\\

\begin{register}{H}{Future capabilities register}{FCPB~-~0x0C}
    \label{reg_fcpb}%
    \regfield{Reserved}{32}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[Request~Depth]
        \item [Reserved] This register is reserved for future features.
\end{reglist}\end{regdesc}\end{register}


%DEBUG: DESCRIPTOR CONTROL WORD
\paragraph{Descriptor control word for debug capability}.\\

\begin{register}{H}{Descriptor control word for debug capability}{DCTR~-~0x010}
    \label{reg_dctr}%
    \regfield{ctrl}{32}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[Request~Depth]
        \item [ctrl]Current descriptor's control field for debug capability.
\end{reglist}\end{regdesc}\end{register}


% DEBUG: NEXT DESCRIPTOR POINTER
\paragraph{Next descriptor pointer for debug capability}.\\

\begin{register}{H}{Next descriptor pointer for debug capability}{DNXT~-~0x014}
    \label{reg_dnxt}%
    \regfield{addr}{32}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[Request~Depth]
        \item [addr]Next descriptor field for debug capability.
\end{reglist}\end{regdesc}\end{register}

\newpage
% DEBUG: DESTINATION ADDRESS
\paragraph{Destination address for debug capability}.\\

\begin{register}{H}{Destination address for debug capability}{DDST~-~0x018}
    \label{reg_ddst}%
    \regfield{addr}{32}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[Request~Depth]
        \item [addr]Current descriptor’s destination address field for debug capability.
\end{reglist}\end{regdesc}\end{register}


% DEBUG: SOURCE ADDRESS
\paragraph{Source address for debug capability}.\\

\begin{register}{H}{Source address for debug capability}{DSRC~-~0x01C}
    \label{reg_dsrc}%
    \regfield{addr}{32}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[Request~Depth]
        \item [addr]Current descriptor’s source address field for debug capability.
\end{reglist}\end{regdesc}\end{register}


% DEBUG: DESCRIPTOR STATUS
\paragraph{Descriptor descriptor status for debug capability}.\\

\begin{register}{H}{Descriptor status for debug capability}{DSTS~-~0x020}
    \label{reg_dsts}%
    \regfield{sts}{32}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[Request~Depth]
        \item [sts]Current descriptor’s status word for debug capability.
\end{reglist}\end{regdesc}\end{register}


% DEBUG: CURRENT DESCRIPTOR POINTER
\paragraph{Current descriptor pointer for debug capability}.\\

\begin{register}{H}{Current descriptor pointer debug capability}{DPTR~-~0x024}
    \label{reg_dptr}%
    \regfield{addr}{32}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[Request~Depth]
        \item [addr]Pointer from which the current descriptor is read, for debug capability.
\end{reglist}\end{regdesc}\end{register}



